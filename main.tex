\documentclass[cic,tc,english]{iiufrgs}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{times}
% \usepackage{palatino}
% \usepackage{mathptmx}       % p/ usar fonte Adobe Times nas fórmulas

\usepackage[alf,abnt-emphasize=bf]{abntex2cite}

\usepackage{lipsum}

\usepackage{revisornotes}
\usepackage{draftenvironment}

\usepackage{ragged2e}

\usepackage{listings}

\usepackage{amsmath}      % For math symbols
\usepackage[boxed]{algorithm}    % For the algorithm environment
\usepackage{algpseudocode} % For pseudocode formatting
\usepackage{xcolor}       % Optional for colored comments

\usepackage{tikz}

\usepackage{amsfonts}

\usepackage[bottom]{footmisc}

\usepackage{amssymb}

\title{
    A Hybrid Multi-Authority Attribute-Based Encryption scheme implementation for securing hIoT data
}
\translatedtitle{
    Um Esquema Híbrido de Criptografia Baseada em Atributos de Múltiplas Autoridades para Transmissão Segura de Dados hIoT
}

\author{Graeff}{Felipe de Almeida}

\advisor[Prof.~Dr.]{Nobre}{Jéferson Campos}
\coadvisor[M.Sc]{Soares}{Laura Rodrigues}

% \date{maio}{2001}
% \location{Itaquaquecetuba}{SP}

\keyword{cryptographic algorithms}
\keyword{IPFS}
\keyword{decentralized technologies}
\keyword{performance analysis}
\keyword{security evaluation}
\keyword{data storage}
\keyword{data exchange}

\translatedkeyword{algoritmos criptográficos}
\translatedkeyword{IPFS}
\translatedkeyword{tecnologias descentralizadas}
\translatedkeyword{análise de desempenho}
\translatedkeyword{avaliação de segurança}
\translatedkeyword{armazenamento de dados}
\translatedkeyword{intercâmbio de dados}

%\settowidth{\seclen}{1.10~}

\begin{document}

\maketitle

% dedicatory
\input{dedicatory.tex}

\chapter*{Acknowledgements}
    I would like to express my gratitude to my advisor, Professor Jéferson Campos Nobre, for his guidance and expertise throughout my research journey. His patience and profound knowledge have incentivised me to pursue this area of research.

    I am immensely thankful to Laura, whose foundational research laid the groundwork for this thesis. Her dedication and help have significantly contributed to the success of this project.

    My appreciation also extends to the faculty and staff at the Informatics Department. The education and support provided by the professors have been fundamental to my academic and professional growth. Their dedication to creating a nurturing and challenging academic environment has been critical to my development.

    Special thanks go to Valéria, my best friend, for her constant support and love. Her encouragement has been a pillar of strength in difficult times, reminding me of the value of perseverance.

    I am grateful to all my friends for their continued encouragement and belief in my abilities. Their support and the occasional much-needed distractions have helped me maintain my focus and passion for my research.

    Finally, I would like to thank Marina and Pedro, my psychologist and psychiatrist. Their professional support has been crucial in managing the stress of my academic commitments, significantly contributing to my well-being and success.

    This thesis reflects the collective support and encouragement of all those mentioned and many others, to whom I am deeply thankful.

\input{epigraph.tex}

\begin{abstract}
    \lipsum[1]
\end{abstract}

\begin{translatedabstract}
    \lipsum[1]
\end{translatedabstract}

\listoffigures

\listoftables

\listofalgorithms

\begin{listofabbrv}{MA-ABE} % longest abbreviation
    \item[AES] Advanced Encryption Standard
    \item[API] Application Programming Interface
    \item[DLP] Discrete Logarithm Problem
    \item[CBC] Cipher Block Chaining
    \item[ECC] Elliptic Curve cryptography
    \item[ECDLP] Elliptic Curve Discrete Logarithm Problem
    \item[EHR] Electronic Health Record
    \item[EMR] Electronic Medical Record
    \item[HIoT] Health Internet of Things
    \item[IoMT] Internet of Medical Things
    \item[IPFS] InterPlanetary File System
    \item[JSON] JavaScript Object Notation
    \item[MA-ABE] Multi-Authority Attribute-Based Encryption
    \item[NIST] National Institute of Standards and Technology
    \item[PoS] Proof of Stake
    \item[PoW] Proof of Work
    \item[REST] Representational State Transfer
    \item[RSA] Rivest-Shamir-Adleman
    \item[SHA] Secure Hash Algorithm
    \item[SIFF] Secure Identity Federation Framework
    \item[WSGI] Web Server Gateway Interface
\end{listofabbrv}

\begin{listofsymbols}{$\alpha\beta\pi\omega$}
    \item[$E_{K_{G_T}}$] Encrypted element $K_{G_T}$
    \item[$E_{\text{payload}}$] Encrypted payload data
    \item[$K_A$] Authorities' public keys
    \item[$K_{G_T}$] Element in the pairing group $G_T$
    \item[$K_{\text{SHA}}$] Hashed symmetric key
    \item[$K_{\text{user}}$] User attribute keys
\end{listofsymbols}

\tableofcontents

\clearpage
\ToDo{
    \begin{itemize}
        \item[$\boxtimes$] Terminar testes de tamanho de chave e tamanho de payload criptografado
        \item[$\square$] Colocar todas as abreviações na lista de abreviações
        \item[$\square$] Colocar abreviações por extenso somente na primeira ocorrência
    \end{itemize}
}

\chapter{Introduction}
    \label{chap:introduction}
    % contextualização 1
    \begin{draft}{Talk about lauras paper}
        Laura's paper ...
        \ToDo{Perguntar pra Laura em que camada do framework dela entra a criptografia}    
    \end{draft}


    % contextualização 2 - mais especificacao
    \begin{draft}{Talk specifities about the technologies used in the framework and why security is relevant and not adressed by IPFS and Hyperledger}
        IPFS \cite{benet2013ipfs} is a peer-to-peer (P2P) decentralized storage system based on a content-addressable block storage model.
    \end{draft}

    % trabalhos relacionacios
    \begin{draft}{Talk about related works}
        
    \end{draft}

    \begin{draft}{Gap}
        No entanto, nenhum dos trabalhos ...
    \end{draft}

    % proposta

    In the present thesis, we aim to propose a cryptography framework that best fits the solution introduced by \citet{laura2023}.

    % (opcional) avaliação (implementação, experimentos, resultados)

    \begin{draft}{Quick introduction of each chapter}
        In Section \ref{chap:relatedworks},...

    \end{draft}

\chapter{Background}
    \label{chap:background}

    \citet{laura2023} proposed a new framework for securing Health Internet of Things (HIoT) data. The framework aims to provide a secure and decentralized storage solution for HIoT data using InterPlanetary File System (IPFS) \cite{benet2013ipfs} for decentralized storage and Hyperledger Fabric \cite{fabric} for access control and data management. However, the framework lacks a robust cryptographic solution to ensure data confidentiality, data ownership, access control, and privacy. We extend their framework by proposing a hybrid cryptographic approach to enhance the security of the system and enable fine-grained access control based on user attributes.

    In this work, the key generation and encryption processes adopt a hybrid cryptographic approach that combines elliptic curve cryptography (ECC), pairing-based cryptography (PBC), and symmetric encryption using the Advanced Encryption Standard (AES). The system implements a Multi-Authority Attribute-Based Encryption (MA-ABE) scheme, enabling fine-grained and flexible access control based on user attributes distributed across multiple independent authorities. ECC and PBC provide the foundation for secure key establishment and attribute-based policies, while AES ensures efficient encryption of large data volumes. This combination leverages the strengths of each technique to achieve both performance and robust access control.



    Section~\ref{sec:ecc} provides an overview of elliptic curve cryptography, including the definition of elliptic curves and their use in cryptographic systems. Section~\ref{sec:pairing} introduces pairing-based cryptography and its applications in advanced cryptographic constructions. Section~\ref{sec:maabe} describes Multi-Authority Attribute-Based Encryption (MA-ABE) and its benefits for secure data sharing in decentralized systems. Section~\ref{sec:symmetric} presents the Advanced Encryption Standard (AES) and its role in symmetric encryption. Section~\ref{sec:blockchain} discusses the application of blockchain technology in healthcare and its potential to enhance data security and privacy. Further details on how these cryptographic techniques are integrated into the proposed framework are provided in Chapter~\ref{chap:proposedsolution}.
    

    \section{Elliptic Curve Cryptography}
        \label{sec:ecc}

        \citet{hankerson2004guide} define Elliptic Curve Cryptography (ECC) as a public-key cryptosystem based on the algebraic structure of elliptic curves over finite fields. Its security relies on the difficulty of the Elliptic Curve Discrete Logarithm Problem (ECDLP), which is believed to be computationally infeasible to solve in general-purpose cases~\citep{hankerson2004guide, koblitz1987elliptic}.

        Let $p$ be a prime number, and let $\mathbb{F}_p$ denote the finite field of integers modulo $p$. An elliptic curve $E$ over $\mathbb{F}_p$ is defined by the Weierstrass equation:

        \begin{equation}
        \label{eq:elliptic_curve}
        y^2 = x^3 + ax + b
        \end{equation}

        where $a, b \in \mathbb{F}_p$ are curve parameters chosen such that the curve is non-singular, i.e., $4a^3 + 27b^2 \neq 0$. The set of points $(x, y) \in \mathbb{F}_p^2$ satisfying this equation, together with a special point at infinity, form an abelian group under a well-defined addition operation~\citep{hankerson2004guide}.

    \section{Pairing-Based Cryptography}
        \label{sec:pairing}

        Pairing-based cryptography extends the use of elliptic curves by employing bilinear pairings, which are maps of the form:

        \begin{equation}
        e: G_1 \times G_2 \rightarrow G_T
        \end{equation}

        where $G_1$ and $G_2$ are additive cyclic groups of points on elliptic curves, and $G_T$ is a multiplicative cyclic group of a finite field~\citep{boneh2001identity}. The pairing $e$ satisfies the following properties:

        \begin{itemize}
            \item \textbf{Bilinearity}: $e(aP, bQ) = e(P, Q)^{ab}$ for all $P \in G_1$, $Q \in G_2$, and integers $a, b$.
            \item \textbf{Non-degeneracy}: There exist points $P \in G_1$ and $Q \in G_2$ such that $e(P, Q) \neq 1$.
            \item \textbf{Computability}: The pairing $e(P, Q)$ can be efficiently computed using algorithms such as Miller's algorithm~\citep{miller1986use}.
        \end{itemize}

        Pairings enable advanced cryptographic constructions, including identity-based encryption (IBE), attribute-based encryption (ABE) and short signatures~\citep{boneh2001identity}.

    \section{Multi-Authority Attribute-Based Encryption (MA-ABE)}
        \label{sec:maabe}
        Attribute-Based Encryption (ABE) is a cryptographic scheme that allows encryption and decryption operations based on user attributes rather than individual identities~\citep{goyal2006attribute}. In a Multi-Authority ABE (MA-ABE) model, multiple independent authorities manage disjoint sets of attributes, improving decentralization and resistance to single points of failure~\citep{chase2007multi}. Each authority issues keys corresponding to the attributes it controls, enabling fine-grained access policies defined over attributes from multiple domains.
        
        MA-ABE is particularly suitable for systems where sensitive data access must be controlled by multiple stakeholders, as is the case in healthcare scenarios. The combination with pairing-based cryptography enables efficient implementation of complex access policies.

        
    \section{Symmetric Encryption with AES}
        \label{sec:symmetric}
        The Advanced Encryption Standard (AES) is a symmetric block cipher standardized by the National Institute of Standards and Technology (NIST)~\citep{daemen1999aes}. It operates on fixed-size blocks of data (typically 128 bits) and supports key sizes of 128, 192, or 256 bits. AES is widely used for data confidentiality due to its efficiency and strong security guarantees.
        
        In this system, AES is used to encrypt large datasets stored off-chain, while the encryption keys are protected using the MA-ABE scheme. This hybrid design ensures both performance and access control granularity.
        
    \section{Blockchain Technology in Healthcare}
        \label{sec:blockchain}
        \Graeff{Laura consegue me ajudar nessa seção?}


\chapter{Related Works}
    \label{chap:relatedworks}
    %\Laura{pela quantidade de texto acho que ficaria melhor fazer um capítulo de background primeiro com a parte de ECC, ABE etc e alguma coisa de blockchain, e aí colocar o reated depois em um capítulo separado} feito
    %\Laura{o problem statement daí pode vir no final do capítulo de related} feito

    This chapter delves into the application of blockchain technology in healthcare, exploring its impact on data security, privacy enhancement, operational efficiency, and additional technological perspectives. Each study discussed is highlighted for its contributions and relevance to advancing blockchain in healthcare.

    \ToDo{Explicar o método utilizado par chegar nos artigos}

    \ToDo{This chapter is divided as follows...}


    \section{Overall Context}
        \label{sec:overallcontext}
        \Laura{Esse aqui seria o 3.1, com um textinho introdutório sobre o contexto geral da minha dissertaçao, e aí data security, privacy enhancement, operational efficiency etc estariam dentro dessa seção - 3.1.1, 3.1.2 etc}
            
        \ToDo{Descrever cada item antes de descrever os trabalhos}
        \subsection{Data Security} 
            \citet{Memos2021} propose a layered cloud architecture incorporating Advanced Encryption Standard (AES) and Rivest-Shamir-Adleman (RSA) encryption to enhance the security of e-health data transmission. \citet{Tian2019} use Secure Identity Federation Framework (SIFF) and Hyperledger Fabric to ensure medical data's integrity, availability, and privacy. \citet{Liu2024} develop a blockchain-based Electronic Medical Record (EMR) sharing scheme with IPFS for secure storage and proxy re-encryption for access control. Additionally, \citet{Esposito2018} investigate the use of blockchain to enhance data security in cloud-based healthcare systems, addressing vulnerabilities inherent in traditional security models.
        
        \subsection{Privacy Enhancement} 
            \citet{Dwivedi2019} propose a blockchain framework for IoT devices in healthcare that minimizes computational demands while enhancing privacy. \citet{Esfahani2024} introduce a comprehensive privacy scheme using zero-knowledge proofs and ring signatures for IoT-based systems. \citet{Zala2024} enhance e-health data privacy through an attribute-based encryption scheme that improves anonymity. \citet{Li2024} create a regulated medical data trading scheme that ensures privacy and compliance using blockchain and zero-knowledge proofs.
        
        \subsection{Operational Efficiency} 
            \citet{Vazirani2019} review the effectiveness of blockchain in managing healthcare records, noting improvements in interoperability. \citet{Shen2019} introduce MedChain, a framework that efficiently manages and shares healthcare data. \citet{Bhansali2022} integrate ciphertext-policy attribute-based encryption with federated learning for data management in the IoMT. Furthermore, \citet{XuJie2019} develop 'Healthchain,' a scalable blockchain-based framework for privacy-preserving health data management.
        
        \subsection{Cross-Border Data Sharing and Scalability} 
            \citet{Rahman2020} describe a blockchain-based platform for secure cross-border data sharing, enhancing trust and security. \citet{Saeed2022} examine the potential of blockchain in healthcare, particularly its impact on managing, distributing, and processing medical records.
        
        \subsection{Additional Technological Perspectives} 
            \citet{Hema2019} assess ECC-based encryption mechanisms for securing healthcare data in cloud environments. \citet{Naz2024} explore defences against quantum computing threats in blockchain through exotic signatures. \citet{Eghmazi2024} focus on securing IoT data using Hyperledger Fabric for scalable solutions. \citet{XuChang2019} discuss secure data sharing in cloud-assisted healthcare systems using cryptographic techniques. Lastly, \citet{Karaca2019} explores mobile cloud computing applications in stroke care, indirectly underscoring the need for integrating secure and efficient technology solutions in healthcare.

    

    \section{Secure Data Sharing and Storing in hIoT}
        \label{sec:securedata}\

    \section{Problem Statement}
        \label{sec:problemstatement}
        \Graeff{Não tenho certeza se é melhor colocar essa discussão dos gaps da literatura aqui como sessão. Aceito sugestões.}
        \Laura{Aqui você vai colocar como subseção os tópicos que vão voltar na discussão lá no final, quando tu for falar que o teu trabalho serviu pra resolver esses problemas que vc trouxe aqui.}

        This section outlines research areas in blockchain technology for healthcare that require further exploration. These areas, identified based on the limitations and gaps in current literature, present significant opportunities to advance the field. This thesis aims to address these opportunities through targeted research objectives.

        \subsection{Scalability and Real-World Applicability} 
            A critical gap in current research on blockchain in healthcare is the need for substantial empirical evidence regarding the scalability of the proposed frameworks and real-world applicability. There is an urgent need to conduct large-scale pilot studies and real-world implementations to substantiate the theoretical advantages of blockchain in this sector. Such research is vital to validate the benefits and to pinpoint potential challenges in diverse healthcare settings. Addressing these gaps is essential for generating concrete data and insights that can guide the scalable deployment of blockchain technologies in practical environments.

        \subsection{Regulatory and Ethical Considerations} 
            Understanding its regulatory and ethical implications is crucial as blockchain technology becomes more integrated into healthcare systems. There is a pressing need to investigate how to design blockchain solutions to comply with healthcare regulations and ethical standards. This exploration should focus on critical areas such as patient privacy, data security, and consent management, encompassing theoretical and practical applications. Ensuring blockchain solutions are legally compliant and ethically sound while maintaining operational flexibility and scalability is fundamental to successful integration into healthcare systems. Addressing these considerations is vital for building trust and accepting blockchain technology in healthcare.

        \subsection{Cybersecurity Challenges} 
            The advancement of blockchain technology in healthcare must continuously adapt to the evolving landscape of cybersecurity threats. Significant opportunities exist to develop sophisticated defence mechanisms specifically designed to address the unique security challenges of blockchain's decentralized nature. Critical areas for further exploration include advancing cryptographic techniques, enhancing consensus algorithms, and implementing robust access control frameworks. These elements protect sensitive health data against unauthorized access and cyber-attacks. Addressing these critical vulnerabilities is imperative to ensuring the security and privacy of healthcare information managed via blockchain. By fortifying these areas, we can significantly enhance the trustworthiness and reliability of blockchain applications in healthcare settings.

\chapter{Proposed Solution}
    \label{chap:proposedsolution}
    This chapter presents the proposed solution for enhancing the security of Health Internet of Things (HIoT) data storage and sharing. The approach integrates blockchain-based storage with a hybrid cryptographic scheme using Multi-Authority Attribute-Based Encryption (MA-ABE). The solution builds upon the framework proposed by \citet{laura2023}, addressing its lack of cryptographic mechanisms by incorporating a layered encryption strategy.

    The solution consists of a hybrid cryptographic approach that combines symmetric encryption for payload protection and MA-ABE for secure key distribution. This chapter focuses solely on the cryptographic mechanisms designed and implemented in this work.

    \section{Hybrid Multi-Authority Attribute-Based Encryption Scheme for Securing HIoT Data}
    \label{sec:encryption}

        This section presents the cryptographic core of the proposed solution, which uses a hybrid encryption scheme combining MA-ABE and symmetric encryption using AES. The goal is to achieve efficient, fine-grained access control for large hIoT payloads.

        \subsection{Overview of the Encryption and Decryption Workflows}
            The encryption process consists of the following stages:
            \begin{enumerate}
                \item Authorities are initialized and generate public/private key pairs.
                \item Users are assigned attributes and corresponding secret keys by the authorities.
                \item A symmetric key is randomly generated as an element of the pairing group $G_T$.
                \item The symmetric key is hashed with SHA-256 to derive an AES key.
                \item The payload is encrypted with AES.
                \item The original symmetric key is encrypted using MA-ABE under a specified attribute policy.
            \end{enumerate}

            The decryption process involves the following steps:
            \begin{enumerate}
                \item Users possess secret keys associated with their attributes, issued by different authorities.
                \item The encrypted symmetric key (an element of $G_T$) is decrypted using MA-ABE, if the user's attributes satisfy the access policy.
                \item The recovered element from $G_T$ is hashed with SHA-256 to derive the AES key.
                \item The payload is decrypted using AES with the derived key.
                \item The plaintext is unpadded to retrieve the original data.
            \end{enumerate}

            This ensures that only users who possess the required attributes can decrypt the MA-ABE-encrypted symmetric key and subsequently access the payload.


        \subsection{Key Management and Distribution}
            The key management system is designed to handle the generation, storage, and distribution of keys securely. Each authority generates its public/private key pair and distributes the public keys to users. The private keys are securely stored and used for generating user-specific keys based on their attributes.

        \subsection{Key Generation and Authority Setup}
            Authorities generate keys using the MaabeRW15 scheme from the Charm-Crypto library. Each authority is responsible for a disjoint subset of attributes and securely stores its private key. Public keys are distributed system-wide.

        \subsection{Access Policy Specification}
            Encryption policies are defined using boolean expressions over attributes, such as in the example policy~\ref{eq:policy_example}, where the attributes are specified in the format "<attribute>@<authority>". The policy can include AND, OR, and NOT operations to define complex access conditions. This allows for flexible and fine-grained access control based on user attributes.
            This policy structure allows flexible definitions of access, combining multiple authorities and domains.

            \begin{equation}
                \label{eq:policy_example}
                \texttt{(\allowbreak doctor@HOSPITAL \allowbreak AND \allowbreak researcher@UNIVERSITY) \allowbreak OR \allowbreak regulator@GOVERNMENT}
            \end{equation}


        \subsection{Security and Performance Considerations}
            This scheme ensures:
            \begin{itemize}
            \item \textbf{Fine-grained access control}: via MA-ABE policies.
            \item \textbf{Efficiency}: AES handles bulk data, reducing computational cost.
            \item \textbf{Scalability}: Multiple authorities reduce centralization and key distribution bottlenecks.
            \end{itemize}

            Further evaluation of performance and scalability is provided in Chapter~\ref{chap:evaluation}.


\chapter{Experimental Setup}
\label{chap:experimentalsetup}

This chapter presents the algorithmic design of the proof-of-concept implementation based on the cryptographic Here, we detail the key routines responsible for authority initialization, attribute-based key generation, and the hybrid encryption and decryption processes. Additionally, we include schematic illustrations and pseudocode to clarify the functional logic of each step.

    \section{Authority and Key Management}
    \label{sec:authority-key-management}

    Introduction paragraph

        \subsection{Authority Setup}

            Each authority is identified by a unique identifier and is responsible for managing a disjoint subset of attributes. During the setup phase, each authority generates a public and private key pair using a multi-authority attribute-based encryption scheme. The public key is made available to all clients, while the private key is securely stored and used later to issue attribute-based keys.

            \begin{algorithm}
                \caption{Setup Authority}
                \label{alg:setup_authority}
                \begin{algorithmic}[1]
                \Procedure{SetupAuthority}{authority}
                    \State $pk, sk \gets \textsc{generateAuthorityKeys}()$
                    \State $\textsc{storeAuthorityKeys}(authority, pk, sk)$
                \EndProcedure
                \end{algorithmic}
            \end{algorithm}

        \subsection{Attribute-Based Key Generation}
            Once an authority is initialized, it can issue secret key components to users based on their assigned attributes. Each key is generated using the authority's private key and the attribute identifier.

            \begin{algorithm}
                \caption{Key Generation}
                \label{alg:keygen}
                \begin{algorithmic}[1]
                \Procedure{Keygen}{authority, attribute, user}
                    \State $sk \gets \textsc{retrieveAuthorityPrivateKey}(authority)$
                    \State $K \gets \textsc{generateKey}(sk, attribute)$
                    \State $\textsc{storeKey}(user, K)$
                \EndProcedure
                \end{algorithmic}
            \end{algorithm}

    \section{Hybrid Encryption Workflow}
    \label{sec:encryption-workflow}
        This section describes the procedure used to encrypt a data payload using a hybrid approach that combines symmetric encryption with attribute-based access control. Access is restricted based on boolean expressions over user attributes.

        \begin{figure}[h]
        \centering
        \begin{tikzpicture}[node distance=7em]
            \usetikzlibrary{positioning, fit}

            \tikzset{
                startstop/.style = {rectangle, rounded corners, minimum width=10em, minimum height=3em, text centered, draw=black, fill=gray!30},
                process/.style = {rectangle, minimum width=10em, minimum height=3em, text centered, draw=black, fill=white!30},
                arrow/.style = {thick,->,>=stealth}
            }

            \node (start) [startstop] {Start};
            \node (gt) [process, below of=start, node distance=6em] {Generate element of $G_T$};
            \node (sha) [process, below right of=gt, xshift=10em, yshift=-2em] {Derive AES key (SHA-256)};
            \node (aes) [process, below of=sha, node distance=6em] {AES.encrypt(payload)};
            \node (maabe) [process, below left of=gt, xshift=-10em, yshift=-5em] {MA-ABE.encrypt($G_T$)};
            \node (return) [process, below of=gt, node distance=14em] {Return Encrypted Payload and Key};
            \node (stop) [startstop, below of=return, node distance=6em] {End};

            \draw [arrow] (start) -- (gt);
            \draw [arrow] (gt) -- (sha);
            \draw [arrow] (gt) -- (maabe);
            \draw [arrow] (sha) -- (aes);
            \draw [arrow] (maabe) -- (return);
            \draw [arrow] (aes) -- (return);
            \draw [arrow] (return) -- (stop);
        \end{tikzpicture}
        \caption{Hybrid encryption process combining symmetric and attribute-based encryption}
        \label{fig:encrypt_process}
        \end{figure}

        \subsection{AES Key Derivation}

            A random element is first generated in the bilinear pairing group $G_T$. This element is then serialized and hashed using SHA-256 to obtain a 256-bit AES key.

            \begin{equation}
            \text{hashed\_key} = \text{SHA-256}(\text{serialized}(K_{G_T}))
            \end{equation}

        \subsection{Payload Encryption}

            The payload is padded to match the AES block size and encrypted using the derived key in CBC mode. Simultaneously, the original element in $G_T$ is encrypted using the attribute-based encryption scheme under a specified access policy.

            \begin{algorithm}
                \caption{Encryption Process}
                \label{alg:encryption_process}
                \scriptsize
                \begin{algorithmic}[1]
                \Procedure{Encrypt}{payload, policy}
                    \State $K_{G_T} \gets \textsc{Random}(G_T)$
                    \State $A \gets \textsc{getAuthorities}(\text{policy})$
                    \State $K_{\textsc{A}} \gets \textsc{retrievePublicKeys}(A)$
                    \State $K_{\textsc{SHA}} \gets \textsc{SHA256}(K_{G_T})$
                    \State $E_{K_{G_T}} \gets \textsc{maabe.Encrypt}(K_{\textsc{A}}, K_{G_T}, \text{policy})$
                    \State $E_{\text{payload}} \gets \textsc{AES.encrypt}(\text{payload}, K_{\textsc{SHA}})$
                    \State \Return $E_{K_{G_T}}, E_{\text{payload}}$
                \EndProcedure
                \end{algorithmic}
            \end{algorithm}

    \section{Decryption Workflow}
    \label{sec:decryption-workflow}

        To recover the original data, the user must possess the necessary set of attributes to satisfy the encryption policy.

        \begin{enumerate}
            \item The MA-ABE-encrypted key element is decrypted using the user's attribute-based secret keys.
            \item The resulting group element is hashed using SHA-256 to regenerate the AES key.
            \item The AES key is used to decrypt the payload.
            \item Padding is removed to retrieve the original data.
        \end{enumerate}

        \begin{algorithm}
            \caption{Decryption Process}
            \label{alg:decryption_process}
            \scriptsize
            \begin{algorithmic}[1]
            \Procedure{Decrypt}{$E_{K_{G_T}}$, $E_{\text{payload}}$, $K_{\text{user}}$}
                \State $K_{G_T} \gets \textsc{maabe.Decrypt}(E_{K_{G_T}}, K_{\text{user}})$
                \State $K_{\textsc{SHA}} \gets \textsc{SHA256}(K_{G_T})$
                \State $payload \gets \textsc{AES.decrypt}(E_{\text{payload}}, K_{\text{SHA}})$
                \State \Return $payload$
            \EndProcedure
            \end{algorithmic}
        \end{algorithm}





\chapter{Evaluation}
    \label{chap:evaluation}
    This chapter presents the implementation details and performance evaluation of the cryptographic system proposed in the previous chapters. We describe the technologies used, the deployment environment, the testing methodology, and the results obtained under different configurations. To ensure reproducibility of results, all source code developed for this project has been archived and made publicly available through Zenodo~\citep{maabeflask}.

    

    \section{Evaluation Strategy and Testbed}
        \label{sec:evaluation-setup}
        This section outlines the evaluation methodology and presents the test environment used to assess the performance of the implemented system. We begin by defining the evaluation objectives, then describe the hardware and software used. Finally, we introduce the tools and configurations employed during the experiments.

        \subsection{Evaluation Objectives}
        \label{subsec:evaluation-objectives}
            The main objectives of the evaluation are to measure the system's performance in terms of response time, determine its scalability under increasing workloads, and assess the cryptographic overhead introduced by the MA-ABE scheme. In addition, we aim to understand how the number of user attributes affects key size and to verify the security functionality of the implementation.

        \subsection{Hardware and Software Environment}
        \label{subsec:hardware-software}
            The experiments were conducted on a single machine whose specifications are listed in Table~\ref{tab:machine_specs}. This section describes the hardware and operating system used, providing context for interpreting the performance results presented later in this chapter.


            \begin{table}[h]
                \centering
                \begin{tabular}{|l|l|}
                \hline
                \textbf{Component} & \textbf{Details} \\ \hline
                OS & Linux Mint 22 (x86\_64) \\ \hline
                Host & HP ZBook Firefly 14" G10 A \\ \hline
                Kernel & 6.8.0-49-generic \\ \hline
                Processor & AMD Ryzen 5 PRO 7640HS (12 cores) @ 5.015GHz \\ \hline
                Memory & 16 GiB \\ \hline
                \end{tabular}
                \caption{Machine Specifications}
                \label{tab:machine_specs}
            \end{table}

            
            \subsection{Implementation Tools}
            \label{subsec:tools}

                To evaluate the implementation of the proposed scheme, we used several tools and frameworks that support API development, cryptographic computation, concurrency management, and load testing.

                \textbf{Locust} is a Python-based API load testing tool that allows the definition of user behavior scenarios to simulate concurrent usage. It generates load on the system to evaluate responsiveness and performance under various conditions. We configured it with varying numbers of users and spawn rates to assess scalability.

                \textbf{Gunicorn} is a Web Server Gateway Interface (WSGI) server for Python applications. It enables concurrent request handling through configurable worker processes and threads. We varied the number of threads and workers to test different concurrency configurations and identify an optimal setup.

                \textbf{Charm-Crypto} is a Python library for pairing-based cryptography that offers high-level abstractions for implementing complex cryptographic protocols. It supports a variety of schemes, including Multi-Authority Attribute-Based Encryption (MA-ABE). In our implementation, we used the \emph{MaabeRW15} scheme proposed by Rouselakis and Waters~\citep{rouselakis2015efficient}, which provides efficient support for multi-authority setups. Charm-Crypto handled all cryptographic operations in our system.

                \textbf{Flask} is a lightweight web framework for Python used to implement the RESTful API for encryption and decryption operations. Its simplicity and extensibility made it suitable for rapid prototyping of the service layer.

                \textbf{Flask-RESTX} is an extension to Flask that provides tooling for building REST APIs, including automatic request parsing and Swagger documentation support. It was used to define and document the API endpoints in a structured and maintainable way.

                % \textbf{PyCryptodome} is a self-contained cryptographic library for Python that implements low-level primitives such as AES. It was used to perform symmetric encryption and decryption of the payloads in CBC mode, using keys derived from MA-ABE-encrypted elements.
                % Cryptodome foi substituido pela implementação do AES da Charm-Crypto, que é mais simples e não precisa de instalação separada.

                \textbf{Redis} is an in-memory key-value store used for managing and persisting cryptographic keys across authorities and users. In our implementation, Redis served as a lightweight and fast-access backend for storing public/private key pairs and attribute-based user keys during testing. It was deployed as a service within a Docker Compose network, alongside the API and other components, ensuring isolated environments and consistent behavior across test executions.

                All services, including the API, Redis, and test agents, were containerized using Docker and orchestrated with Docker Compose to enable reproducible testing conditions and simplify deployment.



            
            

    % \section{Tests}
    %     \label{sec:tests}

    %     \begin{draft}
    %         {Laura esteve aqui}
    %         This section presents the experiments we used to evaluate the proposed secure data sharing scheme based on MA-ABE. We first tested the failure rate to ensure the encrypt and decrypt methods were working as expected. Then, we evaluated the system performance in means of response time with varying parameters. [completar com o resto dos testes.] Table \ref{tab:machine_specs} details the machine specifications in which the experiments were conducted.
    %     \end{draft}

    %     This section presents the experiments we used to evaluate the proposed secure data sharing scheme based on MA-ABE. We first evaluated the system performance in terms of response time by varying the number of threads and workers. Then we tested the response time by varying the payload size, number of concurrent users, and size of the encryption policy. Finally, we evaluated the user key size as a consequence of the number of attributes of the user. The tests were conducted on a machine with the specifications shown in Table~\ref{tab:machine_specs}.


        

        \begin{table}
            \centering
            \begin{tabular}{|c|c|}
                \hline
                \textbf{Threads} & \textbf{Workers} \\ \hline
                1 & 1 \\ \hline
                8 & 5 \\ \hline
                12 & 10 \\ \hline
                16 & 15 \\ \hline
                24 & 20 \\ \hline    
                32 & 25 \\ \hline
            \end{tabular}
            \caption{Number of threads and workers used in the tests}
            \label{tab:threads_workers}
        \end{table}

        % Deprecated section. The results are not relevant anymore.
        % \subsection{Failure Rate}
        %     \label{sec:failurerate}
        %     This test was done with the Locust framework to determine the failure rate of the system. The test was conducted with a payload size of 1KB and 1000 users. The failure rate was calculated by the number of failed requests divided by the total number of requests.

        %     The locustfile used for the test defines 80\% of the users as clients and 20\% as authorities. Each authority instance calls the endpoint \emph{/api/setup\_authority} once upon instantiation, and subsequently calls \emph{/api/keygen} for a user following a Round-Robin strategy. The client instances call the \emph{/api/encrypt} endpoint with a random payload and access policy and then call the \emph{/api/decrypt} endpoint with the encrypted payload and the user's key with a 50\% probability of calling each endpoint.
            
        %     The test was run for 15 minutes with a spawn rate of 100 user per second. The failure rate was calculated as the number of failed requests divided by the total number of requests.

        %     \begin{figure}[h]
        %         \centering
        %         \includegraphics[width=\textwidth]{images/phase1/failure_rate__api_encrypt.png}
        %         \caption{Failure rate for /api/encrypt for different configurations of threads and workers}
        %         \label{fig:failurerateencrypt}
        %     \end{figure}

        %     \begin{figure}[h]
        %         \centering
        %         \includegraphics[width=\textwidth]{images/phase1/failure_rate__api_decrypt.png}
        %         \caption{Failure rate for /api/decrypt for different configurations of threads and workers}
        %         \label{fig:failureratedecrypt}
        %     \end{figure}

        \section{Performance analysis}
            \label{sec:timeencryptdecrypt}

            We evaluated the performance of the encryption and decryption processes using the REST API. The tests were conducted with varying numbers of threads and workers to determine the optimal configuration for the system. The response time for encryption and decryption was measured for different payload sizes to assess the system's scalability and efficiency.

            

            Figure~\ref{fig:encrypt_response_time_threads} shows the response time for encryption by fixing the number of workers and varying the numbers of threads. The median response time is not affected in a considerable way by the number of threads, indicating that the system is not CPU-bound. In contrast, Figure~\ref{fig:encrypt_response_time_workers} presents the response time for encryption by fixing the number of threads and varying the numbers of workers. The response time decreases exponentially as the number of workers increases, indicating that the system is I/O-bound.

            Due to the system's I/O-bound nature, we decided to use a single thread and multiple workers for the subsequent tests.

            \begin{figure}
                \centering
                \includegraphics[width=\textwidth]{images/phase1/api_encrypt/response_time_workers_summary.png}
                \caption{Response time for encryption varying the number of threads}
                \label{fig:encrypt_response_time_workers}
            \end{figure}

            \begin{figure}
                \centering
                \includegraphics[width=\textwidth]{images/phase1/api_decrypt/response_time_workers_summary.png}
                \caption{Response time for decryption varying the number of threads}
                \label{fig:decrypt_response_time_workers}
            \end{figure}

            \begin{figure}
                \centering
                \includegraphics[width=\textwidth]{images/phase1/api_decrypt/response_time_threads_summary.png}
                \caption{Response time for encryption varying the number of workers}
                \label{fig:encrypt_response_time_threads}
            \end{figure}

            \begin{figure}
                \centering
                \includegraphics[width=\textwidth]{images/phase1/api_decrypt/response_time_threads_summary.png}
                \caption{Response time for decryption varying the number of workers}
                \label{fig:decrypt_response_time_threads}
            \end{figure}


            Gunicorn's documentation\footnote{\url{https://docs.gunicorn.org/en/latest/design.html}} states that the optimal number of workers is defined by the formula~\ref{form:numberworkers}. Given the specifications of Table~\ref{tab:machine_specs}, the number of workers used in the subsequent tests is 25.

            \begin{equation}
                \label{form:numberworkers}
                \text{workers} = (2 \times \text{cores}) + 1
            \end{equation}


        \section{Scalability}
            \label{sec:encryptiontime}
            Scalability tests were divided into three phases. The first phase evaluated the system's performance under different payload sizes. The second phase assessed the system's scalability under different user loads. The third phase analyzed the system's performance with varying encryption policy sizes.

            \subsection{Payload Size}
                The results are presented in Figure~\ref{fig:encrypt_payload_size} and in Figure~\ref{fig:decrypt_payload_size}.

                Detailed results are presented in Table~\ref{tab:response_times}.

                \begin{figure}
                    \centering
                    \includegraphics[width=\textwidth]{images/phase2/response_time_api_encrypt.png}
                    \caption{Comparison of encryption time for different payload sizes}
                    \label{fig:encrypt_payload_size}
                \end{figure}

                \begin{figure}
                    \centering
                    \includegraphics[width=\textwidth]{images/phase2/response_time_api_decrypt.png}
                    \caption{Comparison of decryption time for different payload sizes}
                    \label{fig:decrypt_payload_size}
                \end{figure}

                \begin{table}[!ht]
                    \centering
                    \begin{tabular}{|l|l|l|l|l|}
                    \hline
                        Name & Mean Response Time &  Std Dev & Total Requests & RPS \\ \hline
                        /api/decrypt & 273.514862 & 71.377752 & 7423 & 12.445094 \\ \hline
                        /api/encrypt & 57.374965 & 52.18.612973 & 7539 & 12.590557 \\ \hline
                    \end{tabular}
                    \caption{Summary of response times for different endpoints}
                    \label{tab:response_times}
                \end{table}

            \subsection{User load}
                The results are presented in Figure~\ref{fig:encrypt_user_load} and in Figure~\ref{fig:decrypt_user_load}.

                \begin{figure}
                    \centering
                    \includegraphics[width=\textwidth]{images/phase3/response_time_api_encrypt_64KB.png}
                    \caption{Comparison of encryption time for different user loads}
                    \label{fig:encrypt_user_load}
                \end{figure}

                \begin{figure}
                    \centering
                    \includegraphics[width=\textwidth]{images/phase3/response_time_api_decrypt_64KB.png}
                    \caption{Comparison of decryption time for different user loads}
                    \label{fig:decrypt_user_load}
                \end{figure}

            \subsection{Size of encription policy}
                The results are presented in Figure~\ref{fig:encrypt_policy_size} and in Figure~\ref{fig:decrypt_policy_size}.

                \ToDo{Explicar em algum lugar como funcionam a policies}

                \begin{figure}
                    \centering
                    \includegraphics[width=\textwidth]{images/phase4/response_time_api_encrypt.png}
                    \caption{Comparison of encryption time for different policy sizes}
                    \label{fig:encrypt_policy_size}
                \end{figure}

                \begin{figure}
                    \centering
                    \includegraphics[width=\textwidth]{images/phase4/response_time_api_decrypt.png}
                    \caption{Comparison of decryption time for different policy sizes}
                    \label{fig:decrypt_policy_size}
                \end{figure}

        \section{User key size}
            \label{sec:keysize}
            Figure~\ref{fig:user_key_size} shows the size of the user key for different number of attributes. The user key size increases linearly, reaching 25KB for 100 attributes.

            \ToDo{Fazer paralelo com trabalho da Laura e mostrar impacto da criptografia no armazenamento do payload nos blocos do IPFS}

            \begin{figure}
                \centering
                \includegraphics[width=\textwidth]{images/key_size_analysis/user_key_size_analysis.png}
                \caption{Comparison of user key size for different number of attributes}
                \label{fig:user_key_size}
            \end{figure}

        

        \section{Security Test}
            \label{sec:securitytest}

    \section{Results}
        \label{sec:results}

    \section{Discussion}
        \label{sec:discussion}
        Ficou tudo uma bosta e não deu certo pq...

        Falar sobre o multi-thread e pq não funcionou. (evitar sincericídio)

        Charm crypto compila a parte de matematica da curva e faz load em um .so. Talvez isso seja a causa das falhas com multiplas threads

\Laura{olhar related works seção 3.3}

\chapter{Conclusion}
    \label{chap:conclusion}

    \section{Future Work}
        \label{sec:futurework}
        Latencia com a criptografia integrada ao framework da laura

        Tempo pra buscar chaves

        Alternativas para armazenamento das chaves, tonarnando a aplicação mais cpu bound

        Implementaion in a true distributed environment with multiple nodes


\bibliographystyle{abntex2-alf}
\bibliography{biblio}

\end{document}
